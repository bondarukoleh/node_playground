External app:
(App type)    Node -> Streaming -> Use a subshell? -> No -> fork 
              Non-Node:
(Interface type)        Streaming -> Use a subshell? -> No -> spawn
                        Buffered (callback) -> Use a subshell? -> No -> execFile
                                                                -> Yes -> exec
  The child_process module provides four different methods for executing external
applications. All methods are asynchronous. The right method will depend on
what you need, as shown in figure 8.1.
■ execFile—Execute an external application, given a set of arguments, and callback
with the buffered output after the process exits.
■ spawn—Execute an external application, given a set of arguments, and provide
a streaming interface for I/O and events for when the process exits.
■ exec—Execute one or more commands inside a shell and callback with the
buffered output after the process exits.
■ fork—Execute a Node module as a separate process, given a set of arguments,
provide a streaming and evented interface like spawn, and also set up an interprocess
communication (IPC) channel between the parent and child process.

Windows/UNIX has a PATH environment variable. PATH contains a list of directories where executable programs
exist. If a program exists in one of the listed directories, it can be located without
needing an absolute or relative path to the application.


EXECFILE
The output from our external app is buffered internally. When our external app exits, our callback is called
with the output.execvp behind the scenes will search for applications using PATH when no
absolute or relative location is provided. We can see this in our earlier example, since
directories to common system applications like echo usually exist in PATH already.
If the directory containing the application isn’t in PATH, you’ll need to provide the
location explicitly like you would on the command line:
cp.execFile('/absolute/path/to/app' ...
cp.execFile('../relative/path/to/app' ...
Add path before any execFile calls:
process.env.PATH += ':/a/new/path/to/executables';
ENOENT - app doesn't exist;
EACCES or EPERM error - exists but node cannot access it;

SPAWN
Same as execFile - but returns a stream. Spawn method returns a ChildProcess object containing stdin,
stdout, and stderr stream objects.

EXEC
This method will spawn a subshell and execute the command in that shell and buffer generated data. 

If you need to execute commands in a shell, you can use exec. The exec method runs
the commands with /bin/sh or cmd.exe (on Windows). Running commands in a shell
means you have access to all the functionality provided by your particular shell (like
pipes, redirects, and backgrounding).

Comparing to execFile and spawn, exec doesn’t have an args argument because exec allows us to execute
more than one command on a shell. When using exec, if we need to pass arguments to the command,
they should be part of the whole command string.

exec should be used when we need to utilize shell functionality such as pipe, redirects, backgrounding…

If we want to run command with arguments that user provides - it can be dangerous.
he  can provide something like xmllint --schema ; rm -rf / ; the.xml
";" - means start a new command.
If you need to run an application and don’t need shell facilities, it’s safer (and
slightly faster) to use execFile instead:
cp.execFile('xmllint', ['--schema', req.query.schema, 'the.xml']);
Here this malicious injection attack would fail since it’s not run in a shell and the external
application likely wouldn’t understand the argument and would raise an error.

Detaching a child process
Made to not be affected if this process will fail. It's like an different process.
You have a long-running external application that you want Node to start but then be
able to exit with the child process still running.

Attached child process exits when Node exits but Detached child process is process leader and lives
independent of Node.
Normally, any child process will be terminated when the parent Node process is terminated.
Child processes are said to be attached to the parent process. But the spawn
method includes the ability to detach a child process and promote it to be a process
group leader. In this scenario, if the parent is terminated, the child process will continue
until finished.
This scenario is useful when you want Node to set up the execution of a longrunning
external process and you don’t need Node to babysit it after it starts.
This is the detached option, configurable as part of a third options parameter to
spawn:
const detachedProcess = cp.spawn('./longrunApp', [], { detached: true });

The stdio option defines where the I/O from a child process will be redirected.
It takes either an array or a string as a value.The string values are simply shorthands that
will expand to common array configurations.
The array is structured such that the indexes correspond to file descriptors in the
child process and the values indicate where the I/O for the particular file descriptor
(FD) should be redirected.
By default, stdio is configured as
stdio: 'pipe'
which is a shorthand for the following array values:
stdio: [ 'pipe', 'pipe', 'pipe' ]

The pipe value connects the parent and child processes because these streams stay
open, waiting to write or read data. But sometimes, we want to disconnect the
two in order to exit the Node process. A brute-force approach would be to simply
destroy all the streams created:
child.stdin.destroy();
child.stdout.destroy();
child.stderr.destroy();
Although this would work, given our intent to not use them, it’s better to not create
the streams in the first place. Instead, we can assign a file descriptor if we want to
direct the I/O elsewhere or use ignore to discard it completely.

The child process will live on because it’s detached and the I/O is
disconnected from the parent. But the parent still has an internal reference to the
child process and won’t exit until the child process has finished and the reference has been removed.
You can use the child.unref() method to tell Node not to include this child process
reference in its count.

To make a complitely separate child, detach a process requires three things:
■ The detached option must be set to true so the child becomes its own process leader.
■ The stdio option must be configured so the parent and child are disconnected.
■ The reference to the child must be disconnected in the parent using child.unref().