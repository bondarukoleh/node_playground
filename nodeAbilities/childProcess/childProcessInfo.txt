External app:
(App type)    Node -> Streaming -> Use a subshell? -> No -> fork 
              Non-Node:
(Interface type)        Streaming -> Use a subshell? -> No -> spawn
                        Buffered (callback) -> Use a subshell? -> No -> execFile
                                                                -> Yes -> exec
  The child_process module provides four different methods for executing external
applications. All methods are asynchronous. The right method will depend on
what you need, as shown in figure 8.1.
■ execFile—Execute an external application, given a set of arguments, and callback
with the buffered output after the process exits.
■ spawn—Execute an external application, given a set of arguments, and provide
a streaming interface for I/O and events for when the process exits.
■ exec—Execute one or more commands inside a shell and callback with the
buffered output after the process exits.
■ fork—Execute a Node module as a separate process, given a set of arguments,
provide a streaming and evented interface like spawn, and also set up an interprocess
communication (IPC) channel between the parent and child process.

Windows/UNIX has a PATH environment variable. PATH contains a list of directories where executable programs
exist. If a program exists in one of the listed directories, it can be located without
needing an absolute or relative path to the application.


EXECFILE
The output from our external app is buffered internally. When our external app exits, our callback is called
with the output.execvp behind the scenes will search for applications using PATH when no
absolute or relative location is provided. We can see this in our earlier example, since
directories to common system applications like echo usually exist in PATH already.
If the directory containing the application isn’t in PATH, you’ll need to provide the
location explicitly like you would on the command line:
cp.execFile('/absolute/path/to/app' ...
cp.execFile('../relative/path/to/app' ...
Add path before any execFile calls:
process.env.PATH += ':/a/new/path/to/executables';
ENOENT - app doesn't exist;
EACCES or EPERM error - exists but node cannot access it;

SPAWN
Same as execFile - but returns a stream. Spawn method returns a ChildProcess object containing stdin,
stdout, and stderr stream objects.

EXEC
This method will spawn a subshell and execute the command in that shell and buffer generated data. 

If you need to execute commands in a shell, you can use exec. The exec method runs
the commands with /bin/sh or cmd.exe (on Windows). Running commands in a shell
means you have access to all the functionality provided by your particular shell (like
pipes, redirects, and backgrounding).

Comparing to execFile and spawn, exec doesn’t have an args argument because exec allows us to execute
more than one command on a shell. When using exec, if we need to pass arguments to the command,
they should be part of the whole command string.

exec should be used when we need to utilize shell functionality such as pipe, redirects, backgrounding…

If we want to run command with arguments that user provides - it can be dangerous.
he  can provide something like xmllint --schema ; rm -rf / ; the.xml
";" - means start a new command.
If you need to run an application and don’t need shell facilities, it’s safer (and
slightly faster) to use execFile instead:
cp.execFile('xmllint', ['--schema', req.query.schema, 'the.xml']);
Here this malicious injection attack would fail since it’s not run in a shell and the external
application likely wouldn’t understand the argument and would raise an error.